import fs from "fs";
import {
  type CircuitConfig,
  type ProofResult,
  getProverTomlPath,
  generateWitness,
  generateGroth16Proof,
  readProofFiles,
} from "@solana-noir-examples/lib/proof";

export {
  type CircuitConfig,
  type ProofResult,
  createInstructionData,
} from "@solana-noir-examples/lib/proof";

export interface SmtExclusionInputs {
  smt_root: string;
  pubkey_hash: string;
  pubkey: number[];
  siblings: string[];
  leaf_value: string;
}

function formatByteArray(bytes: number[]): string {
  const lines: string[] = [];
  for (let i = 0; i < bytes.length; i += 8) {
    const chunk = bytes.slice(i, i + 8);
    lines.push(
      "    " +
        chunk.map((b) => `0x${b.toString(16).padStart(2, "0")}`).join(", ")
    );
  }
  return "[\n" + lines.join(",\n") + "\n]";
}

function formatFieldArray(fields: string[]): string {
  const lines: string[] = [];
  for (let i = 0; i < fields.length; i += 10) {
    const chunk = fields.slice(i, i + 10);
    lines.push("    " + chunk.map((f) => `"${f}"`).join(", "));
  }
  return "[\n" + lines.join(",\n") + "\n]";
}

export function writeSmtProverToml(
  config: CircuitConfig,
  inputs: SmtExclusionInputs
): void {
  const toml = `# SMT Exclusion Proof - Generated by client

# Public inputs
smt_root = "${inputs.smt_root}"
pubkey_hash = "${inputs.pubkey_hash}"

# Private inputs (witness)
pubkey = ${formatByteArray(inputs.pubkey)}

leaf_value = "${inputs.leaf_value}"

siblings = ${formatFieldArray(inputs.siblings)}
`;
  fs.writeFileSync(getProverTomlPath(config), toml);
}

export function generateProof(
  config: CircuitConfig,
  inputs: SmtExclusionInputs
): ProofResult {
  writeSmtProverToml(config, inputs);
  generateWitness(config);
  generateGroth16Proof(config);
  return readProofFiles(config);
}

// Test pubkey: 4fYNw3dojWmQ4dXtSGE9epjRGy9pFSx62YypT7avPYvA
// These values are computed from an empty SMT (no blacklisted keys)
export const TEST_VALUES = {
  pubkey: "4fYNw3dojWmQ4dXtSGE9epjRGy9pFSx62YypT7avPYvA",
};
