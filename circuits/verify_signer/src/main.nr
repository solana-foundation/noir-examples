// Verify valid ECDSA signature without revealing the public key
//
// Public inputs:  hashed_message (what was signed)
// Private inputs: public_key_x, public_key_y, signature
//
// Proves: "I know a valid signature for this message"
// Without revealing: which public key signed it

use std::ecdsa_secp256k1::verify_signature;

fn main(
    public_key_x: [u8; 32],
    public_key_y: [u8; 32],
    signature: [u8; 64],
    hashed_message: pub [u8; 32],
) {
    assert(verify_signature(public_key_x, public_key_y, signature, hashed_message));
}

#[test]
fn test_verify_signature() {
    // Test values generated by generate_prover_values.py
    // Message: "Hello, Noir!" -> SHA256 hash
    let hashed_message: [u8; 32] = [
        117, 129, 151, 32, 99, 203, 78, 52, 134, 125, 46, 171, 172, 54, 175, 168, 112, 69, 215, 193,
        187, 224, 210, 80, 228, 11, 234, 211, 188, 100, 130, 9,
    ];

    let public_key_x: [u8; 32] = [
        29, 60, 120, 235, 12, 227, 45, 87, 166, 252, 199, 157, 105, 180, 228, 65, 195, 58, 111, 174,
        100, 107, 110, 223, 175, 76, 121, 221, 124, 6, 137, 35,
    ];

    let public_key_y: [u8; 32] = [
        16, 148, 82, 163, 30, 86, 222, 126, 37, 108, 81, 24, 140, 85, 167, 250, 97, 213, 141, 166,
        58, 203, 239, 40, 218, 226, 50, 110, 13, 221, 238, 133,
    ];

    let signature: [u8; 64] = [
        142, 2, 235, 173, 176, 68, 192, 221, 242, 79, 53, 250, 196, 175, 73, 207, 18, 48, 152, 97,
        136, 144, 231, 158, 159, 158, 14, 50, 216, 136, 251, 97, 52, 160, 251, 216, 255, 151, 206,
        229, 71, 189, 145, 102, 212, 207, 158, 100, 31, 103, 195, 137, 244, 82, 134, 123, 157, 6,
        71, 47, 252, 186, 19, 217,
    ];

    main(public_key_x, public_key_y, signature, hashed_message);
}
