// Verify valid ECDSA signature without revealing the public key
//
// Public inputs:  message_commitment (poseidon hash of the message)
// Private inputs: public_key_x, public_key_y, signature, hashed_message
//
// Proves: "I know a valid signature for a message with this commitment"
// Without revealing: which public key signed it
//
// The verifier receives message_commitment on-chain and hashed_message off-chain,
// then verifies: poseidon(hashed_message) == message_commitment

use dep::poseidon::poseidon::bn254::hash_2 as poseidon_hash_2;
use std::ecdsa_secp256k1::verify_signature;

/// Convert 16 bytes to Field (little-endian)
fn bytes16_to_field(bytes: [u8; 32], start: u32) -> Field {
    let mut result: Field = 0;
    let mut multiplier: Field = 1;
    for i in 0..16 {
        result = result + (bytes[start + i] as Field) * multiplier;
        multiplier = multiplier * 256;
    }
    result
}

/// Hash 32 bytes to a single Field using poseidon
fn hash_bytes32(bytes: [u8; 32]) -> Field {
    let low = bytes16_to_field(bytes, 0);
    let high = bytes16_to_field(bytes, 16);
    poseidon_hash_2([low, high])
}

fn main(
    public_key_x: [u8; 32],
    public_key_y: [u8; 32],
    signature: [u8; 64],
    hashed_message: [u8; 32],
    message_commitment: pub Field,
) {
    // Verify the commitment matches the message
    let computed_commitment = hash_bytes32(hashed_message);
    assert(computed_commitment == message_commitment);

    // Verify the signature
    assert(verify_signature(public_key_x, public_key_y, signature, hashed_message));
}

#[test]
fn test_verify_signature() {
    // Test values generated by generate_prover_values.py
    // Message: "Hello, Noir!" -> SHA256 hash
    let hashed_message: [u8; 32] = [
        117, 129, 151, 32, 99, 203, 78, 52, 134, 125, 46, 171, 172, 54, 175, 168, 112, 69, 215, 193,
        187, 224, 210, 80, 228, 11, 234, 211, 188, 100, 130, 9,
    ];

    let public_key_x: [u8; 32] = [
        29, 60, 120, 235, 12, 227, 45, 87, 166, 252, 199, 157, 105, 180, 228, 65, 195, 58, 111, 174,
        100, 107, 110, 223, 175, 76, 121, 221, 124, 6, 137, 35,
    ];

    let public_key_y: [u8; 32] = [
        16, 148, 82, 163, 30, 86, 222, 126, 37, 108, 81, 24, 140, 85, 167, 250, 97, 213, 141, 166,
        58, 203, 239, 40, 218, 226, 50, 110, 13, 221, 238, 133,
    ];

    let signature: [u8; 64] = [
        142, 2, 235, 173, 176, 68, 192, 221, 242, 79, 53, 250, 196, 175, 73, 207, 18, 48, 152, 97,
        136, 144, 231, 158, 159, 158, 14, 50, 216, 136, 251, 97, 52, 160, 251, 216, 255, 151, 206,
        229, 71, 189, 145, 102, 212, 207, 158, 100, 31, 103, 195, 137, 244, 82, 134, 123, 157, 6,
        71, 47, 252, 186, 19, 217,
    ];

    // Compute message commitment (poseidon hash of message bytes)
    let message_commitment = hash_bytes32(hashed_message);

    main(
        public_key_x,
        public_key_y,
        signature,
        hashed_message,
        message_commitment,
    );
}
