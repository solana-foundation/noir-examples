{"noir_version":"1.0.0-beta.13+6e469c3004209a8b107e7707306e25c80a110fd6","hash":"8052537876569197955","abi":{"parameters":[{"name":"public_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"public_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hashed_message","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"message_commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/9W9CbgmSVrX+41QQAEFFFBAAQUUUEABBRGRGZEZQAutttJqq6222morkRmR0ECDrY466igDDDDAAAMM++q+7/u+oeJ131FAGkRFRcUd9er9vWdm7s338OnzQLx5n2/OLJWVdc53MjIi3vf//72RkS87veHr02+cTt/1sjccyx9v8cY/5ettrp172ZlzP+rMubc4c+4tz5y7cebcW50599Znzr3NmXM3z5x72zPn3u7Mubc/c+7WmXPvcObcO545905nzt0+c+6dz5x7lzPn3vXMuTtnzr3bmXPvfubce5w5d/fMufc8c+69zpx77zPn7p059z5nzr3vmXPvd+bc/TPn3v/MuQ84c+4Dz5x7cObcB50598Fnzn3ImXMPz5z70DPnPuzMuQ8/c+7RmXMfcebcR545586c82fOhTPnhjPnxjPn4plz6cy56cy5+cy5fObcR50599Fnzn3MmXOPnTn3o8+c+9gz5z7uzLnHz5z7MWfO/dgz537cmXNPnDn348+c+wlnzn38mXNPnjn3E8+c+0lnzv3kM+eeOnPup5w591PPnPtpZ849febcTz9z7mecOfczz5x75sy5n3Xm3M8+c+7nnDn37JlzP/fMuZ935tzPP3PuuTPnfsGZc7/wzLlPOHOunDm3nDm3njlXz5xrZ85tZ8594plzn3Tm3PNnzn3ymXOfcubcp54598KZc5925tynnzn3i86ce/HMuV985twvOXPul5459/Iz537ZmXO//My5X3Hm3CvOnPuVZ879qjPnfvWZc688c+7XnDn3a8+c+4wz51515txnnjn3WWfOffaZc68+c+5zzpz73DPnPu/MudecOff5Z859wZlzX3jm3GvPnPuiM+e++My5Lzlz7nVnzn3pmXNfdubcl5859/oz577izLmvPHPuq86c++oz577mzLmvPXPu686c+/oz577hzLlvfOO5/dftN/75cW/80/V9+c+w+izv3KtsPsvL/32mxWf5N/zxWf2f5d908Nm9n+X/v8NX932W3//lc3o+y+u/fu6P/LP89ROf9yP9LP9DT73mR/ZZ/tzJz/+RfJY/f/oLfvif5f93//CFP9zP8v/7f3rtD++z/P/pH7/oh/NZ/v/8z1+8+6zBpXFsU2h+8MWFvMzRjXFJs599nGMN8zC0eZynvOTJZT8OzW8xD9sbP+ub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","debug_symbols":"tZndTttKGEXfJddczMz+5q+vcnSEAoQqUhRQCpWOUN/9eBwvJ1zYTe1y1Q/2eHfZnmUH+Ng87R7ev9/vj88vPzbf/vnYPJz2h8P++/3h5XH7tn85dt/9+HW34cv7t9Nu131rc5V3R71uT7vj2+bb8f1wuNv83B7e+0U/XrfH/t+37alL3d1md3zq/u0Kn/eHXZt+3V2OdtOHemWO9qplLIifG/xMgwtGg4tuqiFMNxQfh4Iiv+54W/b/cwIl2pLjXfz98bNXMOXxCtbJhrzyCuaVVzCvvIL5C6+gd+Mu9mF6F8/dxNGDUvKlIH4u0HSBxpto7uoc7HOBzZxE1bgNarpiSDdXBBfCUBGcbLIiTVdYzOI8Yi7LKmqlIrm0qCK1dKgIZdm1yOO18MEWVfh4qciTJxL83K4wTkRp+qbOV+iWivkTqWytEFydpLDV+2K+4qZ9MVvxF/ZFUB2vRfWLKuQ9FbI4eSJ1/b6oX7svLI4nYmnyjmjmuZl95tmffbm8PHy5vSKMT60cNFkxfyKF3RmiLbsWMY6OxBIWVaTCHQnZtKxi1GxxxeVtHsrVHfmjCqeVFfKX3elt0lTzqx858xU3PXJmK9Y/ctS9z7kWYdnWkjyfT6TpN7ul1Y+c+YrVjxwpxvFEZijq+n1R1++L+rX7QoXHr8xNvkeiVt/U+YqbburcD5E2vg+9xTD18Xu2obIrfLx+EXUN/3ZfbR/3p08/Om98ct3a7ontk2+vijaE9sm5DSIyokiUiDJDYajD4uyGxdkPUQ5EIjKiSJSIaM405zoMBeYCc4G5wFxgLjAXmEsmKkS1va26oToGzxAY1F4rbbD2UmlDJEpEmagQ1XMUnDtHwfm2Y9sQGMRgDJEhtT3dhty2VRsKUR0G74Y13g9rPM2eZm+siaxJRJmhsKYOa4IbogBzCMOaINbAHGAOMAeYA8wBZsEsmAWzYBbMglkwC2bBLJgNZoPZYDaYDWaD2WA2mA1mgznCHGGOMEeYI8wR5ghzhDnCHGFOMCeYE8wJ5gRzgjnBnGBOMCeYM8wZ5gxzhjnDnGHOMGeYM8wZ5gJzgbnAXGAuMBeYC8wF5gJzgbnCXGGuMFeYK8wV5gpzhbnCXAdmuYFZOCg3MMuJNUYUGRJrMmsK0cAsHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOCgeFg8JB4aBwUDgoHBQOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDhoOGg4aDlpz0EIbumbr13TN1q+JRIkoExWiOkTNwT5qDvaR0dwcPA/GEDkqcVQmKkR1iJqDfdQc7KPm4DmiOdIcYW4OnofMUYWj6hA1B/uoOdhHCebE1UhcjeZgdG1IDJmhMHTN7Vcz1hxsv4S05mAfNQfPkYiMKBIlotbc7k5zsP1+w5qDsX3I/7k97bcPh93wh6jn9+Pj1d+l3v57JeEvV6+nl8fd0/tp1z6I91n30fx/","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n}\n","path":"std/field/mod.nr"},"50":{"source":"// Verify valid ECDSA signature without revealing the public key\n//\n// Public inputs:  message_commitment (poseidon hash of the message)\n// Private inputs: public_key_x, public_key_y, signature, hashed_message\n//\n// Proves: \"I know a valid signature for a message with this commitment\"\n// Without revealing: which public key signed it\n//\n// The verifier receives message_commitment on-chain and hashed_message off-chain,\n// then verifies: poseidon(hashed_message) == message_commitment\n\nuse std::ecdsa_secp256k1::verify_signature;\nuse dep::poseidon::poseidon::bn254::hash_2 as poseidon_hash_2;\n\n/// Convert 16 bytes to Field (little-endian)\nfn bytes16_to_field(bytes: [u8; 32], start: u32) -> Field {\n    let mut result: Field = 0;\n    let mut multiplier: Field = 1;\n    for i in 0..16 {\n        result = result + (bytes[start + i] as Field) * multiplier;\n        multiplier = multiplier * 256;\n    }\n    result\n}\n\n/// Hash 32 bytes to a single Field using poseidon\nfn hash_bytes32(bytes: [u8; 32]) -> Field {\n    let low = bytes16_to_field(bytes, 0);\n    let high = bytes16_to_field(bytes, 16);\n    poseidon_hash_2([low, high])\n}\n\nfn main(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32],\n    message_commitment: pub Field,\n) {\n    // Verify the commitment matches the message\n    let computed_commitment = hash_bytes32(hashed_message);\n    assert(computed_commitment == message_commitment);\n\n    // Verify the signature\n    assert(verify_signature(public_key_x, public_key_y, signature, hashed_message));\n}\n\n#[test]\nfn test_verify_signature() {\n    // Test values generated by generate_prover_values.py\n    // Message: \"Hello, Noir!\" -> SHA256 hash\n    let hashed_message: [u8; 32] = [\n        117, 129, 151, 32, 99, 203, 78, 52, 134, 125, 46, 171, 172, 54, 175, 168, 112, 69, 215, 193,\n        187, 224, 210, 80, 228, 11, 234, 211, 188, 100, 130, 9,\n    ];\n\n    let public_key_x: [u8; 32] = [\n        29, 60, 120, 235, 12, 227, 45, 87, 166, 252, 199, 157, 105, 180, 228, 65, 195, 58, 111, 174,\n        100, 107, 110, 223, 175, 76, 121, 221, 124, 6, 137, 35,\n    ];\n\n    let public_key_y: [u8; 32] = [\n        16, 148, 82, 163, 30, 86, 222, 126, 37, 108, 81, 24, 140, 85, 167, 250, 97, 213, 141, 166,\n        58, 203, 239, 40, 218, 226, 50, 110, 13, 221, 238, 133,\n    ];\n\n    let signature: [u8; 64] = [\n        142, 2, 235, 173, 176, 68, 192, 221, 242, 79, 53, 250, 196, 175, 73, 207, 18, 48, 152, 97,\n        136, 144, 231, 158, 159, 158, 14, 50, 216, 136, 251, 97, 52, 160, 251, 216, 255, 151, 206,\n        229, 71, 189, 145, 102, 212, 207, 158, 100, 31, 103, 195, 137, 244, 82, 134, 123, 157, 6,\n        71, 47, 252, 186, 19, 217,\n    ];\n\n    // Compute message commitment (poseidon hash of message bytes)\n    let message_commitment = hash_bytes32(hashed_message);\n\n    main(public_key_x, public_key_y, signature, hashed_message, message_commitment);\n}\n","path":"/Users/jolana/git-solana/solana-noir-examples/circuits/verify_signer/src/main.nr"},"54":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/Users/jolana/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"55":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/Users/jolana/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"56":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/Users/jolana/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"names":["main"],"brillig_names":[]}